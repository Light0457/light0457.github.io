{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/code/rename_commiter.sh","path":"code/rename_commiter.sh","modified":1,"renderable":0}],"Cache":[{"_id":"source/_drafts/html_css_learning.md","hash":"036d56a2a14d2ee3ce320d366c2deb0f8658756f","modified":1467310007000},{"_id":"source/_posts/ShadowsocksAutoGrabber.md","hash":"250b2fb483909c0a09a7b998590d6408df515812","modified":1467310007000},{"_id":"source/code/rename_commiter.sh","hash":"0c5b93995523ceaa5b881332b3d5f69da4b49bab","modified":1467310007000},{"_id":"source/_posts/ssh/SSHNote.md","hash":"7d52d4cb323a37e7d8d97ba271564b1e4e65e3e4","modified":1467310007000},{"_id":"source/_posts/git/GitChangeCommiterName.md","hash":"3731c8e61ef00659b88b1c33f2e5acd9079fb02a","modified":1467310007000},{"_id":"public/2016/07/01/ShadowsocksAutoGrabber/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239756},{"_id":"public/2016/07/01/ssh/SSHNote/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239756},{"_id":"public/2016/07/01/git/GitChangeCommiterName/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239756},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/archives/2016/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/Shadowsocks/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/plist/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/Alfred/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/ssh/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/tags/git/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1467310239757},{"_id":"public/code/rename_commiter.sh","hash":"0c5b93995523ceaa5b881332b3d5f69da4b49bab","modified":1467310239759}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"科学上网便捷小工具","_content":"# 一、概述  \n\n为啥写这篇文章呢～～主要是想记录下一些琐碎的点。最近折腾“科学上网”查到的信息点太琐碎了，实在构不成完整的知识体系，但相关资料不记下来又可惜了点，没准以后还用到。写篇文章来记最容易检索到了。   \n最近一直用[ShadowsocksX][ShadowsocksXDownload]来上谷歌，服务器用的是从[iShadowsocks][iShadowsocks]网站获取的免费服务器。无耐何它每六个小时更换一次密码。  \n在老老实实手动更新密码一大段时间后，让我知道了mac上的这个软件：[Alfred](https://www.alfredapp.com/)这个软件，这个软件可以方便地运行脚本、启动程序等等小功能。就是它的这些功能使我萌发了写个脚本自动更新服务器密码的想法。才有了这篇文章。\n<!--more-->\n\n# 二、抓取服务器地址信息   \n个人偏好使用Python写这一类的小工具，库多，写着方便，所以下面的脚本大部分都是用Python写的。  \n## 2.1 在Python中访问网站[iShadowsocks][iShadowsocks]  \n要抓取服务器地址信息嘛，访问网站在把网页内容下下来是必须的。在Python中做这点倒是挺简单的，像下面一小段代码就好了。\n\n    import urllib2\n    html_content = urllib2.urlopen(\"http://www.ishadowsocks.net/\").read()\n\n## 2.2 解析网页内容获取服务器地址\npython中解析html网页内容的库有好几个，有[HTMLParser](https://docs.python.org/2/library/htmlparser.html),[HtmlLib](https://docs.python.org/2/library/htmllib.html),[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)。  \n* **HtmlLib**: 已经被官方抛弃掉不建议使用了，不去考虑。  \n* **HTMLParser**: 看了下HTMLParser的使用例子，需要写个解析类继承于HTMLParser。这种方式并不喜欢，因为类继承不方便组织代码，同时还得看需要重载什么函数，重载的函数负责什么职责。\n* **BeautifulSoup**: 对比了下BeautifulSoup，用起来直接是按键值查找，有种将html文件当json来用的感觉，挺好的，写起来省时省力些。  \n\n所以最后用了BeautifulSoup这个库来解析html。  \n打开谷歌浏览器看了下该网站的网页代码，虽然我对html并不熟悉，但那个网页还是挺简洁的，还带了良好的溈，看了一下，\n1. 我们需要的服务器地址的大概位置就是在一个tag是section,id是free的一个容器里面,  \n2. 每个服务器地址的内容使用了一样的div样式，\n3. 服务器地址的每一项内容都是用h4来显示的   \n\n总的来说，内容要挺有规律的，要抓取出来还是比较轻松的。   \n\n    soup = BeautifulSoup(html_content)\n    free_part = soup.find(\"section\",id = \"free\")\n    free_account_parts = free_part.find_all(\"div\",class_ = \"col-lg-4 text-center\")\n    key_parsers = {\n        \"server\": lambda str : u\"服务器地址\" in str,\n        \"server_port\": lambda str : u\"端口\" in str,\n        \"password\": lambda str : u\"密码\" in str,\n        \"method\": lambda str : u\"加密方式\" in str\n    }\n    free_server_infos = []  //** 存储最终抓取到的结果\n    for free_account_part in free_account_parts:             \n        account_infos = free_account_part.find_all(\"h4\")\n        for account_info in account_infos:\n            server_info = {}\n            values = account_info.text.split(u':')\n            if len(values) <= 1:\n                continue\n            for (key, parser) in key_parsers.items():\n                if parser(values[0]):\n                    server_info[key] = values[1]\n            free_server_infos.append(server_info)\n\n# 三、更新ShadowsocksX的配置\nShadowsocksX这个软件呢用着还是挺方便的，无奈我一直找不到它配置的地方。谷歌后在[它的github issue页面](https://github.com/shadowsocks/shadowsocks-iOS/issues/150)发现，Mac下的这个ShadowsocksX软件并没有像其它版本的Shadowsocks一样提供一个可配置的json文件，而使用了苹果的plist文件来存储。它的配置文件就是这个：~/Library/Preferences/clowwindy.ShadowsocksX.plist。\n## 3.1 使用Python读写plist配置文件\npython读写plist的库我是搜到了两个,一个是[plistlib](https://docs.python.org/2/library/plistlib.html),另一个则是[biplist](https://pypi.python.org/pypi/biplist/1.0.1),两个库接口用起来都差不多。由于plistlib是官方库，刚开始选了它。但拿它来读其它plist文件很正常，拿来读clowwindy.ShadowsocksX.plist这个文件却会报错。而用biplist却不会。因此最终选择了biplist做为这次读写plist文件的python库。   \n读写plist文件还是很简单，几句代码就好了\n\n    //** 获取当前用户下的clowwindy.ShadowsocksX.plist路径\n    import os\n    plist_file_path = os.path.join(os.path.expandvars('$HOME'),\"Library/Preferences/clowwindy.ShadowsocksX.plist\")\n\n    import biplist\n    plist = biplist.readPlist(plist_file_path)\n\n由于服务器配置是存在clowwindy.ShadowsocksX.plist这个文件中的content字段，而content字段通过biplist读出来后是一个字符串类型，格式是json格式的，所以我们可以把它用json库解析成我们方便用的字典  \n\n    import json\n    json_config = json.loads(plist[\"config\"])\n\n然后就是将需要更新的内容写进去了。具体写啥就不赘述了。只提下踩到的坑点：\n* clowwindy.ShadowsocksX.plist文件中\"content\"的字段，在Finder下查看是一段经过base64后的字符串，但这并不需要作者手动去base64下那个字段，只要是写入时指定存储进去的内容是Data类型的，plist库就会对应的将其base64后写进去。如果自己手动base64后再当成字符串存储进去，产生的文件是不一样的。使用biplist库则是使用biplist.Data包裹一下要写的内容\n\n        plist[\"config\"] = biplist.Data(json.dumps(json_config, indent=None, separators=(',', ':')))\n\n## 3.2 更新Mac OS X系统中的plist缓存\n修改完clowwindy.ShadowsocksX.plist这个文件后，神奇的发现它并没有生效，让我一度怀疑ShadowsocksX的配置文件是不是这个。直接在ShadowsocksX更改配置信息，内容确实会更新到这个文件上面来。然后直接修改这个文件的内容，信息却不会及时更新到ShadowsocksX的界面上去。   \n经过n多试验后，发现只有完全重启了mac，才能将修改的配置文件生效。但这显然不够满足我的需求，更新了帐号还要重启那就太蛋疼了。  \n谷歌搜索如何立即生效plist文件，能找到的信息实在是少。几经周折，终于在[http://hints.macworld.com/article.php?story=20130908042828630]()这个网页中，在网友的评论里看到相关的信息。\n问题所在：   \n*  There are many hints here and on the net involving changing user defaults by **running defaults write or directly editing the .plist files in Library/Preferences**. Until 10.9, restarting the program was enough to apply the new defaults.**Since OS X Mavericks**, the defaults system is caching the preferences **system-wide (i.e. not in the application's process!)** to improve performance of the user defaults API. （也就是说，从OS X Mavericks之后，使用mac命令行defaults更改Library/Preferences下面的plist文件后并不会立即生效，必须重启后才生效，因为OS X Mavericks会缓存这些配置，以提高使用defaults读写plist文件时的效率。但是在此却给了我好大烦恼的说～）\n* The API documentation states that the cache is synchronized with the on-disk plist file contents periodically, but does not indicate how often, let alone how to flush the cache manually.Logging out and back in appears to flush the user defauts cache, but other than that, *the defaults command is currently the only way to reliably change preferences **without waiting for the timeout***.（说是API文档虽然指出会周期性的同步缓存，但没说是周期是多久。但至少我们知道了defaults操作一下plist文件是可以直接更新缓存的，不用等待系统某个时机去更新缓存）   \n\n看到了问题所在，同时也在评论中看到了解决方法：\n* This had me stumped for a while while trying to restore my preference files. So, after copying or editing a plist, for example com.rstudio.desktop.plist , just run **defaults read com.rstudio.desktop** which should *sync the cache*.（也就是说执行一下defaults read **.plist文件就可以更新系统中的plist缓存了）   \n\n那这样我们就可以把更新缓存的代码在python中补上,defaults read一下配置文件。\n\n    os.system(\"defaults read \" + plist_file_path)\n\n# 四、Alfred中按全局快捷键更新服务器信息\n用Alfred配置快捷键执行某个脚本挺简单的，也不赘述了。只说下按快捷键后要执行的脚本内容。\n1. 为了更新ShadowsocksX的配置，需要把运行中的ShadowsocksX给关掉（当然没有运行的就不用了）。\n这个与系统直接打交道的用shell命令简单些。\nmac下杀死指定进程的shell命令是kill，不过这个只能通过指定进程的pid来杀，没法通过进程名来杀。  \n然后查到有个killall命令，可以杀掉指定进程名的进程（据说这个在unix系统上不能随便执行～）。\n不过对于我们来说够用了。执行shell命令:\n\n        killall ShadowsocksX\n\n2. 执行我们刚刚写好的python脚本。    \n这边有坑，在Alfred执行的python环境不一定是我们写python脚本时的环境，所以如果无法执行，则只好手动指定python的路径来执行我们的脚本了，例如：\n\n        /Library/Frameworks/Python.framework/Versions/2.7/bin/python ShadowsocksXAutoSetter.py\n\n---\n[ShadowsocksXDownload]: https://sourceforge.net/projects/shadowsocksgui/\n[ShadowsocksXHelp]: https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9\n[iShadowsocks]: http://www.ishadowsocks.net/\n","source":"_posts/ShadowsocksAutoGrabber.md","raw":"---\ntitle: 科学上网便捷小工具\ntags: \n- Shadowsocks     \n- plist   \n- Alfred    \n- python   \n---\n# 一、概述  \n\n为啥写这篇文章呢～～主要是想记录下一些琐碎的点。最近折腾“科学上网”查到的信息点太琐碎了，实在构不成完整的知识体系，但相关资料不记下来又可惜了点，没准以后还用到。写篇文章来记最容易检索到了。   \n最近一直用[ShadowsocksX][ShadowsocksXDownload]来上谷歌，服务器用的是从[iShadowsocks][iShadowsocks]网站获取的免费服务器。无耐何它每六个小时更换一次密码。  \n在老老实实手动更新密码一大段时间后，让我知道了mac上的这个软件：[Alfred](https://www.alfredapp.com/)这个软件，这个软件可以方便地运行脚本、启动程序等等小功能。就是它的这些功能使我萌发了写个脚本自动更新服务器密码的想法。才有了这篇文章。\n<!--more-->\n\n# 二、抓取服务器地址信息   \n个人偏好使用Python写这一类的小工具，库多，写着方便，所以下面的脚本大部分都是用Python写的。  \n## 2.1 在Python中访问网站[iShadowsocks][iShadowsocks]  \n要抓取服务器地址信息嘛，访问网站在把网页内容下下来是必须的。在Python中做这点倒是挺简单的，像下面一小段代码就好了。\n\n    import urllib2\n    html_content = urllib2.urlopen(\"http://www.ishadowsocks.net/\").read()\n\n## 2.2 解析网页内容获取服务器地址\npython中解析html网页内容的库有好几个，有[HTMLParser](https://docs.python.org/2/library/htmlparser.html),[HtmlLib](https://docs.python.org/2/library/htmllib.html),[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)。  \n* **HtmlLib**: 已经被官方抛弃掉不建议使用了，不去考虑。  \n* **HTMLParser**: 看了下HTMLParser的使用例子，需要写个解析类继承于HTMLParser。这种方式并不喜欢，因为类继承不方便组织代码，同时还得看需要重载什么函数，重载的函数负责什么职责。\n* **BeautifulSoup**: 对比了下BeautifulSoup，用起来直接是按键值查找，有种将html文件当json来用的感觉，挺好的，写起来省时省力些。  \n\n所以最后用了BeautifulSoup这个库来解析html。  \n打开谷歌浏览器看了下该网站的网页代码，虽然我对html并不熟悉，但那个网页还是挺简洁的，还带了良好的溈，看了一下，\n1. 我们需要的服务器地址的大概位置就是在一个tag是section,id是free的一个容器里面,  \n2. 每个服务器地址的内容使用了一样的div样式，\n3. 服务器地址的每一项内容都是用h4来显示的   \n\n总的来说，内容要挺有规律的，要抓取出来还是比较轻松的。   \n\n    soup = BeautifulSoup(html_content)\n    free_part = soup.find(\"section\",id = \"free\")\n    free_account_parts = free_part.find_all(\"div\",class_ = \"col-lg-4 text-center\")\n    key_parsers = {\n        \"server\": lambda str : u\"服务器地址\" in str,\n        \"server_port\": lambda str : u\"端口\" in str,\n        \"password\": lambda str : u\"密码\" in str,\n        \"method\": lambda str : u\"加密方式\" in str\n    }\n    free_server_infos = []  //** 存储最终抓取到的结果\n    for free_account_part in free_account_parts:             \n        account_infos = free_account_part.find_all(\"h4\")\n        for account_info in account_infos:\n            server_info = {}\n            values = account_info.text.split(u':')\n            if len(values) <= 1:\n                continue\n            for (key, parser) in key_parsers.items():\n                if parser(values[0]):\n                    server_info[key] = values[1]\n            free_server_infos.append(server_info)\n\n# 三、更新ShadowsocksX的配置\nShadowsocksX这个软件呢用着还是挺方便的，无奈我一直找不到它配置的地方。谷歌后在[它的github issue页面](https://github.com/shadowsocks/shadowsocks-iOS/issues/150)发现，Mac下的这个ShadowsocksX软件并没有像其它版本的Shadowsocks一样提供一个可配置的json文件，而使用了苹果的plist文件来存储。它的配置文件就是这个：~/Library/Preferences/clowwindy.ShadowsocksX.plist。\n## 3.1 使用Python读写plist配置文件\npython读写plist的库我是搜到了两个,一个是[plistlib](https://docs.python.org/2/library/plistlib.html),另一个则是[biplist](https://pypi.python.org/pypi/biplist/1.0.1),两个库接口用起来都差不多。由于plistlib是官方库，刚开始选了它。但拿它来读其它plist文件很正常，拿来读clowwindy.ShadowsocksX.plist这个文件却会报错。而用biplist却不会。因此最终选择了biplist做为这次读写plist文件的python库。   \n读写plist文件还是很简单，几句代码就好了\n\n    //** 获取当前用户下的clowwindy.ShadowsocksX.plist路径\n    import os\n    plist_file_path = os.path.join(os.path.expandvars('$HOME'),\"Library/Preferences/clowwindy.ShadowsocksX.plist\")\n\n    import biplist\n    plist = biplist.readPlist(plist_file_path)\n\n由于服务器配置是存在clowwindy.ShadowsocksX.plist这个文件中的content字段，而content字段通过biplist读出来后是一个字符串类型，格式是json格式的，所以我们可以把它用json库解析成我们方便用的字典  \n\n    import json\n    json_config = json.loads(plist[\"config\"])\n\n然后就是将需要更新的内容写进去了。具体写啥就不赘述了。只提下踩到的坑点：\n* clowwindy.ShadowsocksX.plist文件中\"content\"的字段，在Finder下查看是一段经过base64后的字符串，但这并不需要作者手动去base64下那个字段，只要是写入时指定存储进去的内容是Data类型的，plist库就会对应的将其base64后写进去。如果自己手动base64后再当成字符串存储进去，产生的文件是不一样的。使用biplist库则是使用biplist.Data包裹一下要写的内容\n\n        plist[\"config\"] = biplist.Data(json.dumps(json_config, indent=None, separators=(',', ':')))\n\n## 3.2 更新Mac OS X系统中的plist缓存\n修改完clowwindy.ShadowsocksX.plist这个文件后，神奇的发现它并没有生效，让我一度怀疑ShadowsocksX的配置文件是不是这个。直接在ShadowsocksX更改配置信息，内容确实会更新到这个文件上面来。然后直接修改这个文件的内容，信息却不会及时更新到ShadowsocksX的界面上去。   \n经过n多试验后，发现只有完全重启了mac，才能将修改的配置文件生效。但这显然不够满足我的需求，更新了帐号还要重启那就太蛋疼了。  \n谷歌搜索如何立即生效plist文件，能找到的信息实在是少。几经周折，终于在[http://hints.macworld.com/article.php?story=20130908042828630]()这个网页中，在网友的评论里看到相关的信息。\n问题所在：   \n*  There are many hints here and on the net involving changing user defaults by **running defaults write or directly editing the .plist files in Library/Preferences**. Until 10.9, restarting the program was enough to apply the new defaults.**Since OS X Mavericks**, the defaults system is caching the preferences **system-wide (i.e. not in the application's process!)** to improve performance of the user defaults API. （也就是说，从OS X Mavericks之后，使用mac命令行defaults更改Library/Preferences下面的plist文件后并不会立即生效，必须重启后才生效，因为OS X Mavericks会缓存这些配置，以提高使用defaults读写plist文件时的效率。但是在此却给了我好大烦恼的说～）\n* The API documentation states that the cache is synchronized with the on-disk plist file contents periodically, but does not indicate how often, let alone how to flush the cache manually.Logging out and back in appears to flush the user defauts cache, but other than that, *the defaults command is currently the only way to reliably change preferences **without waiting for the timeout***.（说是API文档虽然指出会周期性的同步缓存，但没说是周期是多久。但至少我们知道了defaults操作一下plist文件是可以直接更新缓存的，不用等待系统某个时机去更新缓存）   \n\n看到了问题所在，同时也在评论中看到了解决方法：\n* This had me stumped for a while while trying to restore my preference files. So, after copying or editing a plist, for example com.rstudio.desktop.plist , just run **defaults read com.rstudio.desktop** which should *sync the cache*.（也就是说执行一下defaults read **.plist文件就可以更新系统中的plist缓存了）   \n\n那这样我们就可以把更新缓存的代码在python中补上,defaults read一下配置文件。\n\n    os.system(\"defaults read \" + plist_file_path)\n\n# 四、Alfred中按全局快捷键更新服务器信息\n用Alfred配置快捷键执行某个脚本挺简单的，也不赘述了。只说下按快捷键后要执行的脚本内容。\n1. 为了更新ShadowsocksX的配置，需要把运行中的ShadowsocksX给关掉（当然没有运行的就不用了）。\n这个与系统直接打交道的用shell命令简单些。\nmac下杀死指定进程的shell命令是kill，不过这个只能通过指定进程的pid来杀，没法通过进程名来杀。  \n然后查到有个killall命令，可以杀掉指定进程名的进程（据说这个在unix系统上不能随便执行～）。\n不过对于我们来说够用了。执行shell命令:\n\n        killall ShadowsocksX\n\n2. 执行我们刚刚写好的python脚本。    \n这边有坑，在Alfred执行的python环境不一定是我们写python脚本时的环境，所以如果无法执行，则只好手动指定python的路径来执行我们的脚本了，例如：\n\n        /Library/Frameworks/Python.framework/Versions/2.7/bin/python ShadowsocksXAutoSetter.py\n\n---\n[ShadowsocksXDownload]: https://sourceforge.net/projects/shadowsocksgui/\n[ShadowsocksXHelp]: https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9\n[iShadowsocks]: http://www.ishadowsocks.net/\n","slug":"ShadowsocksAutoGrabber","published":1,"date":"2016-06-30T18:06:47.000Z","updated":"2016-06-30T18:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq2mmqtz00005ofypcqg30go","content":"<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>为啥写这篇文章呢～～主要是想记录下一些琐碎的点。最近折腾“科学上网”查到的信息点太琐碎了，实在构不成完整的知识体系，但相关资料不记下来又可惜了点，没准以后还用到。写篇文章来记最容易检索到了。<br>最近一直用<a href=\"https://sourceforge.net/projects/shadowsocksgui/\" target=\"_blank\" rel=\"external\">ShadowsocksX</a>来上谷歌，服务器用的是从<a href=\"http://www.ishadowsocks.net/\" target=\"_blank\" rel=\"external\">iShadowsocks</a>网站获取的免费服务器。无耐何它每六个小时更换一次密码。<br>在老老实实手动更新密码一大段时间后，让我知道了mac上的这个软件：<a href=\"https://www.alfredapp.com/\" target=\"_blank\" rel=\"external\">Alfred</a>这个软件，这个软件可以方便地运行脚本、启动程序等等小功能。就是它的这些功能使我萌发了写个脚本自动更新服务器密码的想法。才有了这篇文章。<br><a id=\"more\"></a></p>\n<h1 id=\"二、抓取服务器地址信息\"><a href=\"#二、抓取服务器地址信息\" class=\"headerlink\" title=\"二、抓取服务器地址信息\"></a>二、抓取服务器地址信息</h1><p>个人偏好使用Python写这一类的小工具，库多，写着方便，所以下面的脚本大部分都是用Python写的。  </p>\n<h2 id=\"2-1-在Python中访问网站iShadowsocks\"><a href=\"#2-1-在Python中访问网站iShadowsocks\" class=\"headerlink\" title=\"2.1 在Python中访问网站iShadowsocks\"></a>2.1 在Python中访问网站<a href=\"http://www.ishadowsocks.net/\" target=\"_blank\" rel=\"external\">iShadowsocks</a></h2><p>要抓取服务器地址信息嘛，访问网站在把网页内容下下来是必须的。在Python中做这点倒是挺简单的，像下面一小段代码就好了。</p>\n<pre><code>import urllib2\nhtml_content = urllib2.urlopen(&quot;http://www.ishadowsocks.net/&quot;).read()\n</code></pre><h2 id=\"2-2-解析网页内容获取服务器地址\"><a href=\"#2-2-解析网页内容获取服务器地址\" class=\"headerlink\" title=\"2.2 解析网页内容获取服务器地址\"></a>2.2 解析网页内容获取服务器地址</h2><p>python中解析html网页内容的库有好几个，有<a href=\"https://docs.python.org/2/library/htmlparser.html\" target=\"_blank\" rel=\"external\">HTMLParser</a>,<a href=\"https://docs.python.org/2/library/htmllib.html\" target=\"_blank\" rel=\"external\">HtmlLib</a>,<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"external\">BeautifulSoup</a>。  </p>\n<ul>\n<li><strong>HtmlLib</strong>: 已经被官方抛弃掉不建议使用了，不去考虑。  </li>\n<li><strong>HTMLParser</strong>: 看了下HTMLParser的使用例子，需要写个解析类继承于HTMLParser。这种方式并不喜欢，因为类继承不方便组织代码，同时还得看需要重载什么函数，重载的函数负责什么职责。</li>\n<li><strong>BeautifulSoup</strong>: 对比了下BeautifulSoup，用起来直接是按键值查找，有种将html文件当json来用的感觉，挺好的，写起来省时省力些。  </li>\n</ul>\n<p>所以最后用了BeautifulSoup这个库来解析html。<br>打开谷歌浏览器看了下该网站的网页代码，虽然我对html并不熟悉，但那个网页还是挺简洁的，还带了良好的溈，看了一下，</p>\n<ol>\n<li>我们需要的服务器地址的大概位置就是在一个tag是section,id是free的一个容器里面,  </li>\n<li>每个服务器地址的内容使用了一样的div样式，</li>\n<li>服务器地址的每一项内容都是用h4来显示的   </li>\n</ol>\n<p>总的来说，内容要挺有规律的，要抓取出来还是比较轻松的。   </p>\n<pre><code>soup = BeautifulSoup(html_content)\nfree_part = soup.find(&quot;section&quot;,id = &quot;free&quot;)\nfree_account_parts = free_part.find_all(&quot;div&quot;,class_ = &quot;col-lg-4 text-center&quot;)\nkey_parsers = {\n    &quot;server&quot;: lambda str : u&quot;服务器地址&quot; in str,\n    &quot;server_port&quot;: lambda str : u&quot;端口&quot; in str,\n    &quot;password&quot;: lambda str : u&quot;密码&quot; in str,\n    &quot;method&quot;: lambda str : u&quot;加密方式&quot; in str\n}\nfree_server_infos = []  //** 存储最终抓取到的结果\nfor free_account_part in free_account_parts:             \n    account_infos = free_account_part.find_all(&quot;h4&quot;)\n    for account_info in account_infos:\n        server_info = {}\n        values = account_info.text.split(u&apos;:&apos;)\n        if len(values) &lt;= 1:\n            continue\n        for (key, parser) in key_parsers.items():\n            if parser(values[0]):\n                server_info[key] = values[1]\n        free_server_infos.append(server_info)\n</code></pre><h1 id=\"三、更新ShadowsocksX的配置\"><a href=\"#三、更新ShadowsocksX的配置\" class=\"headerlink\" title=\"三、更新ShadowsocksX的配置\"></a>三、更新ShadowsocksX的配置</h1><p>ShadowsocksX这个软件呢用着还是挺方便的，无奈我一直找不到它配置的地方。谷歌后在<a href=\"https://github.com/shadowsocks/shadowsocks-iOS/issues/150\" target=\"_blank\" rel=\"external\">它的github issue页面</a>发现，Mac下的这个ShadowsocksX软件并没有像其它版本的Shadowsocks一样提供一个可配置的json文件，而使用了苹果的plist文件来存储。它的配置文件就是这个：~/Library/Preferences/clowwindy.ShadowsocksX.plist。</p>\n<h2 id=\"3-1-使用Python读写plist配置文件\"><a href=\"#3-1-使用Python读写plist配置文件\" class=\"headerlink\" title=\"3.1 使用Python读写plist配置文件\"></a>3.1 使用Python读写plist配置文件</h2><p>python读写plist的库我是搜到了两个,一个是<a href=\"https://docs.python.org/2/library/plistlib.html\" target=\"_blank\" rel=\"external\">plistlib</a>,另一个则是<a href=\"https://pypi.python.org/pypi/biplist/1.0.1\" target=\"_blank\" rel=\"external\">biplist</a>,两个库接口用起来都差不多。由于plistlib是官方库，刚开始选了它。但拿它来读其它plist文件很正常，拿来读clowwindy.ShadowsocksX.plist这个文件却会报错。而用biplist却不会。因此最终选择了biplist做为这次读写plist文件的python库。<br>读写plist文件还是很简单，几句代码就好了</p>\n<pre><code>//** 获取当前用户下的clowwindy.ShadowsocksX.plist路径\nimport os\nplist_file_path = os.path.join(os.path.expandvars(&apos;$HOME&apos;),&quot;Library/Preferences/clowwindy.ShadowsocksX.plist&quot;)\n\nimport biplist\nplist = biplist.readPlist(plist_file_path)\n</code></pre><p>由于服务器配置是存在clowwindy.ShadowsocksX.plist这个文件中的content字段，而content字段通过biplist读出来后是一个字符串类型，格式是json格式的，所以我们可以把它用json库解析成我们方便用的字典  </p>\n<pre><code>import json\njson_config = json.loads(plist[&quot;config&quot;])\n</code></pre><p>然后就是将需要更新的内容写进去了。具体写啥就不赘述了。只提下踩到的坑点：</p>\n<ul>\n<li><p>clowwindy.ShadowsocksX.plist文件中”content”的字段，在Finder下查看是一段经过base64后的字符串，但这并不需要作者手动去base64下那个字段，只要是写入时指定存储进去的内容是Data类型的，plist库就会对应的将其base64后写进去。如果自己手动base64后再当成字符串存储进去，产生的文件是不一样的。使用biplist库则是使用biplist.Data包裹一下要写的内容</p>\n<pre><code>plist[&quot;config&quot;] = biplist.Data(json.dumps(json_config, indent=None, separators=(&apos;,&apos;, &apos;:&apos;)))\n</code></pre></li>\n</ul>\n<h2 id=\"3-2-更新Mac-OS-X系统中的plist缓存\"><a href=\"#3-2-更新Mac-OS-X系统中的plist缓存\" class=\"headerlink\" title=\"3.2 更新Mac OS X系统中的plist缓存\"></a>3.2 更新Mac OS X系统中的plist缓存</h2><p>修改完clowwindy.ShadowsocksX.plist这个文件后，神奇的发现它并没有生效，让我一度怀疑ShadowsocksX的配置文件是不是这个。直接在ShadowsocksX更改配置信息，内容确实会更新到这个文件上面来。然后直接修改这个文件的内容，信息却不会及时更新到ShadowsocksX的界面上去。<br>经过n多试验后，发现只有完全重启了mac，才能将修改的配置文件生效。但这显然不够满足我的需求，更新了帐号还要重启那就太蛋疼了。<br>谷歌搜索如何立即生效plist文件，能找到的信息实在是少。几经周折，终于在<a href=\"\">http://hints.macworld.com/article.php?story=20130908042828630</a>这个网页中，在网友的评论里看到相关的信息。<br>问题所在：   </p>\n<ul>\n<li>There are many hints here and on the net involving changing user defaults by <strong>running defaults write or directly editing the .plist files in Library/Preferences</strong>. Until 10.9, restarting the program was enough to apply the new defaults.<strong>Since OS X Mavericks</strong>, the defaults system is caching the preferences <strong>system-wide (i.e. not in the application’s process!)</strong> to improve performance of the user defaults API. （也就是说，从OS X Mavericks之后，使用mac命令行defaults更改Library/Preferences下面的plist文件后并不会立即生效，必须重启后才生效，因为OS X Mavericks会缓存这些配置，以提高使用defaults读写plist文件时的效率。但是在此却给了我好大烦恼的说～）</li>\n<li>The API documentation states that the cache is synchronized with the on-disk plist file contents periodically, but does not indicate how often, let alone how to flush the cache manually.Logging out and back in appears to flush the user defauts cache, but other than that, <em>the defaults command is currently the only way to reliably change preferences <strong>without waiting for the timeout</strong></em>.（说是API文档虽然指出会周期性的同步缓存，但没说是周期是多久。但至少我们知道了defaults操作一下plist文件是可以直接更新缓存的，不用等待系统某个时机去更新缓存）   </li>\n</ul>\n<p>看到了问题所在，同时也在评论中看到了解决方法：</p>\n<ul>\n<li>This had me stumped for a while while trying to restore my preference files. So, after copying or editing a plist, for example com.rstudio.desktop.plist , just run <strong>defaults read com.rstudio.desktop</strong> which should <em>sync the cache</em>.（也就是说执行一下defaults read **.plist文件就可以更新系统中的plist缓存了）   </li>\n</ul>\n<p>那这样我们就可以把更新缓存的代码在python中补上,defaults read一下配置文件。</p>\n<pre><code>os.system(&quot;defaults read &quot; + plist_file_path)\n</code></pre><h1 id=\"四、Alfred中按全局快捷键更新服务器信息\"><a href=\"#四、Alfred中按全局快捷键更新服务器信息\" class=\"headerlink\" title=\"四、Alfred中按全局快捷键更新服务器信息\"></a>四、Alfred中按全局快捷键更新服务器信息</h1><p>用Alfred配置快捷键执行某个脚本挺简单的，也不赘述了。只说下按快捷键后要执行的脚本内容。</p>\n<ol>\n<li><p>为了更新ShadowsocksX的配置，需要把运行中的ShadowsocksX给关掉（当然没有运行的就不用了）。<br>这个与系统直接打交道的用shell命令简单些。<br>mac下杀死指定进程的shell命令是kill，不过这个只能通过指定进程的pid来杀，没法通过进程名来杀。<br>然后查到有个killall命令，可以杀掉指定进程名的进程（据说这个在unix系统上不能随便执行～）。<br>不过对于我们来说够用了。执行shell命令:</p>\n<pre><code>killall ShadowsocksX\n</code></pre></li>\n<li><p>执行我们刚刚写好的python脚本。<br>这边有坑，在Alfred执行的python环境不一定是我们写python脚本时的环境，所以如果无法执行，则只好手动指定python的路径来执行我们的脚本了，例如：</p>\n<pre><code>/Library/Frameworks/Python.framework/Versions/2.7/bin/python ShadowsocksXAutoSetter.py\n</code></pre></li>\n</ol>\n<hr>\n","excerpt":"<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>为啥写这篇文章呢～～主要是想记录下一些琐碎的点。最近折腾“科学上网”查到的信息点太琐碎了，实在构不成完整的知识体系，但相关资料不记下来又可惜了点，没准以后还用到。写篇文章来记最容易检索到了。<br>最近一直用<a href=\"https://sourceforge.net/projects/shadowsocksgui/\">ShadowsocksX</a>来上谷歌，服务器用的是从<a href=\"http://www.ishadowsocks.net/\">iShadowsocks</a>网站获取的免费服务器。无耐何它每六个小时更换一次密码。<br>在老老实实手动更新密码一大段时间后，让我知道了mac上的这个软件：<a href=\"https://www.alfredapp.com/\">Alfred</a>这个软件，这个软件可以方便地运行脚本、启动程序等等小功能。就是它的这些功能使我萌发了写个脚本自动更新服务器密码的想法。才有了这篇文章。<br>","more":"</p>\n<h1 id=\"二、抓取服务器地址信息\"><a href=\"#二、抓取服务器地址信息\" class=\"headerlink\" title=\"二、抓取服务器地址信息\"></a>二、抓取服务器地址信息</h1><p>个人偏好使用Python写这一类的小工具，库多，写着方便，所以下面的脚本大部分都是用Python写的。  </p>\n<h2 id=\"2-1-在Python中访问网站iShadowsocks\"><a href=\"#2-1-在Python中访问网站iShadowsocks\" class=\"headerlink\" title=\"2.1 在Python中访问网站iShadowsocks\"></a>2.1 在Python中访问网站<a href=\"http://www.ishadowsocks.net/\">iShadowsocks</a></h2><p>要抓取服务器地址信息嘛，访问网站在把网页内容下下来是必须的。在Python中做这点倒是挺简单的，像下面一小段代码就好了。</p>\n<pre><code>import urllib2\nhtml_content = urllib2.urlopen(&quot;http://www.ishadowsocks.net/&quot;).read()\n</code></pre><h2 id=\"2-2-解析网页内容获取服务器地址\"><a href=\"#2-2-解析网页内容获取服务器地址\" class=\"headerlink\" title=\"2.2 解析网页内容获取服务器地址\"></a>2.2 解析网页内容获取服务器地址</h2><p>python中解析html网页内容的库有好几个，有<a href=\"https://docs.python.org/2/library/htmlparser.html\">HTMLParser</a>,<a href=\"https://docs.python.org/2/library/htmllib.html\">HtmlLib</a>,<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\">BeautifulSoup</a>。  </p>\n<ul>\n<li><strong>HtmlLib</strong>: 已经被官方抛弃掉不建议使用了，不去考虑。  </li>\n<li><strong>HTMLParser</strong>: 看了下HTMLParser的使用例子，需要写个解析类继承于HTMLParser。这种方式并不喜欢，因为类继承不方便组织代码，同时还得看需要重载什么函数，重载的函数负责什么职责。</li>\n<li><strong>BeautifulSoup</strong>: 对比了下BeautifulSoup，用起来直接是按键值查找，有种将html文件当json来用的感觉，挺好的，写起来省时省力些。  </li>\n</ul>\n<p>所以最后用了BeautifulSoup这个库来解析html。<br>打开谷歌浏览器看了下该网站的网页代码，虽然我对html并不熟悉，但那个网页还是挺简洁的，还带了良好的溈，看了一下，</p>\n<ol>\n<li>我们需要的服务器地址的大概位置就是在一个tag是section,id是free的一个容器里面,  </li>\n<li>每个服务器地址的内容使用了一样的div样式，</li>\n<li>服务器地址的每一项内容都是用h4来显示的   </li>\n</ol>\n<p>总的来说，内容要挺有规律的，要抓取出来还是比较轻松的。   </p>\n<pre><code>soup = BeautifulSoup(html_content)\nfree_part = soup.find(&quot;section&quot;,id = &quot;free&quot;)\nfree_account_parts = free_part.find_all(&quot;div&quot;,class_ = &quot;col-lg-4 text-center&quot;)\nkey_parsers = {\n    &quot;server&quot;: lambda str : u&quot;服务器地址&quot; in str,\n    &quot;server_port&quot;: lambda str : u&quot;端口&quot; in str,\n    &quot;password&quot;: lambda str : u&quot;密码&quot; in str,\n    &quot;method&quot;: lambda str : u&quot;加密方式&quot; in str\n}\nfree_server_infos = []  //** 存储最终抓取到的结果\nfor free_account_part in free_account_parts:             \n    account_infos = free_account_part.find_all(&quot;h4&quot;)\n    for account_info in account_infos:\n        server_info = {}\n        values = account_info.text.split(u&apos;:&apos;)\n        if len(values) &lt;= 1:\n            continue\n        for (key, parser) in key_parsers.items():\n            if parser(values[0]):\n                server_info[key] = values[1]\n        free_server_infos.append(server_info)\n</code></pre><h1 id=\"三、更新ShadowsocksX的配置\"><a href=\"#三、更新ShadowsocksX的配置\" class=\"headerlink\" title=\"三、更新ShadowsocksX的配置\"></a>三、更新ShadowsocksX的配置</h1><p>ShadowsocksX这个软件呢用着还是挺方便的，无奈我一直找不到它配置的地方。谷歌后在<a href=\"https://github.com/shadowsocks/shadowsocks-iOS/issues/150\">它的github issue页面</a>发现，Mac下的这个ShadowsocksX软件并没有像其它版本的Shadowsocks一样提供一个可配置的json文件，而使用了苹果的plist文件来存储。它的配置文件就是这个：~/Library/Preferences/clowwindy.ShadowsocksX.plist。</p>\n<h2 id=\"3-1-使用Python读写plist配置文件\"><a href=\"#3-1-使用Python读写plist配置文件\" class=\"headerlink\" title=\"3.1 使用Python读写plist配置文件\"></a>3.1 使用Python读写plist配置文件</h2><p>python读写plist的库我是搜到了两个,一个是<a href=\"https://docs.python.org/2/library/plistlib.html\">plistlib</a>,另一个则是<a href=\"https://pypi.python.org/pypi/biplist/1.0.1\">biplist</a>,两个库接口用起来都差不多。由于plistlib是官方库，刚开始选了它。但拿它来读其它plist文件很正常，拿来读clowwindy.ShadowsocksX.plist这个文件却会报错。而用biplist却不会。因此最终选择了biplist做为这次读写plist文件的python库。<br>读写plist文件还是很简单，几句代码就好了</p>\n<pre><code>//** 获取当前用户下的clowwindy.ShadowsocksX.plist路径\nimport os\nplist_file_path = os.path.join(os.path.expandvars(&apos;$HOME&apos;),&quot;Library/Preferences/clowwindy.ShadowsocksX.plist&quot;)\n\nimport biplist\nplist = biplist.readPlist(plist_file_path)\n</code></pre><p>由于服务器配置是存在clowwindy.ShadowsocksX.plist这个文件中的content字段，而content字段通过biplist读出来后是一个字符串类型，格式是json格式的，所以我们可以把它用json库解析成我们方便用的字典  </p>\n<pre><code>import json\njson_config = json.loads(plist[&quot;config&quot;])\n</code></pre><p>然后就是将需要更新的内容写进去了。具体写啥就不赘述了。只提下踩到的坑点：</p>\n<ul>\n<li><p>clowwindy.ShadowsocksX.plist文件中”content”的字段，在Finder下查看是一段经过base64后的字符串，但这并不需要作者手动去base64下那个字段，只要是写入时指定存储进去的内容是Data类型的，plist库就会对应的将其base64后写进去。如果自己手动base64后再当成字符串存储进去，产生的文件是不一样的。使用biplist库则是使用biplist.Data包裹一下要写的内容</p>\n<pre><code>plist[&quot;config&quot;] = biplist.Data(json.dumps(json_config, indent=None, separators=(&apos;,&apos;, &apos;:&apos;)))\n</code></pre></li>\n</ul>\n<h2 id=\"3-2-更新Mac-OS-X系统中的plist缓存\"><a href=\"#3-2-更新Mac-OS-X系统中的plist缓存\" class=\"headerlink\" title=\"3.2 更新Mac OS X系统中的plist缓存\"></a>3.2 更新Mac OS X系统中的plist缓存</h2><p>修改完clowwindy.ShadowsocksX.plist这个文件后，神奇的发现它并没有生效，让我一度怀疑ShadowsocksX的配置文件是不是这个。直接在ShadowsocksX更改配置信息，内容确实会更新到这个文件上面来。然后直接修改这个文件的内容，信息却不会及时更新到ShadowsocksX的界面上去。<br>经过n多试验后，发现只有完全重启了mac，才能将修改的配置文件生效。但这显然不够满足我的需求，更新了帐号还要重启那就太蛋疼了。<br>谷歌搜索如何立即生效plist文件，能找到的信息实在是少。几经周折，终于在<a href=\"\">http://hints.macworld.com/article.php?story=20130908042828630</a>这个网页中，在网友的评论里看到相关的信息。<br>问题所在：   </p>\n<ul>\n<li>There are many hints here and on the net involving changing user defaults by <strong>running defaults write or directly editing the .plist files in Library/Preferences</strong>. Until 10.9, restarting the program was enough to apply the new defaults.<strong>Since OS X Mavericks</strong>, the defaults system is caching the preferences <strong>system-wide (i.e. not in the application’s process!)</strong> to improve performance of the user defaults API. （也就是说，从OS X Mavericks之后，使用mac命令行defaults更改Library/Preferences下面的plist文件后并不会立即生效，必须重启后才生效，因为OS X Mavericks会缓存这些配置，以提高使用defaults读写plist文件时的效率。但是在此却给了我好大烦恼的说～）</li>\n<li>The API documentation states that the cache is synchronized with the on-disk plist file contents periodically, but does not indicate how often, let alone how to flush the cache manually.Logging out and back in appears to flush the user defauts cache, but other than that, <em>the defaults command is currently the only way to reliably change preferences <strong>without waiting for the timeout</strong></em>.（说是API文档虽然指出会周期性的同步缓存，但没说是周期是多久。但至少我们知道了defaults操作一下plist文件是可以直接更新缓存的，不用等待系统某个时机去更新缓存）   </li>\n</ul>\n<p>看到了问题所在，同时也在评论中看到了解决方法：</p>\n<ul>\n<li>This had me stumped for a while while trying to restore my preference files. So, after copying or editing a plist, for example com.rstudio.desktop.plist , just run <strong>defaults read com.rstudio.desktop</strong> which should <em>sync the cache</em>.（也就是说执行一下defaults read **.plist文件就可以更新系统中的plist缓存了）   </li>\n</ul>\n<p>那这样我们就可以把更新缓存的代码在python中补上,defaults read一下配置文件。</p>\n<pre><code>os.system(&quot;defaults read &quot; + plist_file_path)\n</code></pre><h1 id=\"四、Alfred中按全局快捷键更新服务器信息\"><a href=\"#四、Alfred中按全局快捷键更新服务器信息\" class=\"headerlink\" title=\"四、Alfred中按全局快捷键更新服务器信息\"></a>四、Alfred中按全局快捷键更新服务器信息</h1><p>用Alfred配置快捷键执行某个脚本挺简单的，也不赘述了。只说下按快捷键后要执行的脚本内容。</p>\n<ol>\n<li><p>为了更新ShadowsocksX的配置，需要把运行中的ShadowsocksX给关掉（当然没有运行的就不用了）。<br>这个与系统直接打交道的用shell命令简单些。<br>mac下杀死指定进程的shell命令是kill，不过这个只能通过指定进程的pid来杀，没法通过进程名来杀。<br>然后查到有个killall命令，可以杀掉指定进程名的进程（据说这个在unix系统上不能随便执行～）。<br>不过对于我们来说够用了。执行shell命令:</p>\n<pre><code>killall ShadowsocksX\n</code></pre></li>\n<li><p>执行我们刚刚写好的python脚本。<br>这边有坑，在Alfred执行的python环境不一定是我们写python脚本时的环境，所以如果无法执行，则只好手动指定python的路径来执行我们的脚本了，例如：</p>\n<pre><code>/Library/Frameworks/Python.framework/Versions/2.7/bin/python ShadowsocksXAutoSetter.py\n</code></pre></li>\n</ol>\n<hr>"},{"title":"SSH使用杂记","_content":"# [SSH网络协议](https://zh.wikipedia.org/wiki/Secure_Shell)使用杂记\n最近寻觅各git托管服务，都选择了用ssh协议来拉取。以及最近因为各种原因接触得比较多，碰到的问题也多了，在这里面记录一下。  \n* 使用\n        ssh-keygen -t rsa -C \"youremail-address\"\n  创建ssh密钥时，\n  1. 要求输入生成文件的目录，此时输入的目录需要是完整路径（也不能用～表示Home目录） \n  2. 要求输入passphrase,这个从目前的用法看就是即将生成的密钥文件的密码，把它添加到ssh agnet的时候需要输入这个密码\n\n<!--more-->\n\n* 在ssh-add密钥后，碰到个问题是重启后还要再添加一遍。\n        ssh-add ~/.ssh/xxx_rsa  \n  这个原因在于ssh-add添加密钥文件，只是用于添加指定文件到当前运行中的ssh agent的session中，重启后session重建，添加的密钥文件也就被重置了（似乎如果创建的密钥文件是默认名id_rsa，则不会有这个问题。可能重启后会添加默认的密钥文件吧）。   \n  解决办法有两个：  \n  1. 在Mac OS X上，系统自带有keychain access这个管理工具，添加密钥文件可以把密钥文件一起添加到keychain access中，方法是ssh-add时多带一个-K参数   \n\n         ssh-add -K ~/.ssh/xxx_rsa\n  \n  2. 在~/.ssh中添加config文件，添加对应网站要使用的密钥文件  \n\n         Host gitlab.com  \n         RSAAuthentication yes \n         IdentityFile ~/.ssh/xxx_rsa\n\n","source":"_posts/ssh/SSHNote.md","raw":"---\ntitle: SSH使用杂记\ntag: ssh\n---\n# [SSH网络协议](https://zh.wikipedia.org/wiki/Secure_Shell)使用杂记\n最近寻觅各git托管服务，都选择了用ssh协议来拉取。以及最近因为各种原因接触得比较多，碰到的问题也多了，在这里面记录一下。  \n* 使用\n        ssh-keygen -t rsa -C \"youremail-address\"\n  创建ssh密钥时，\n  1. 要求输入生成文件的目录，此时输入的目录需要是完整路径（也不能用～表示Home目录） \n  2. 要求输入passphrase,这个从目前的用法看就是即将生成的密钥文件的密码，把它添加到ssh agnet的时候需要输入这个密码\n\n<!--more-->\n\n* 在ssh-add密钥后，碰到个问题是重启后还要再添加一遍。\n        ssh-add ~/.ssh/xxx_rsa  \n  这个原因在于ssh-add添加密钥文件，只是用于添加指定文件到当前运行中的ssh agent的session中，重启后session重建，添加的密钥文件也就被重置了（似乎如果创建的密钥文件是默认名id_rsa，则不会有这个问题。可能重启后会添加默认的密钥文件吧）。   \n  解决办法有两个：  \n  1. 在Mac OS X上，系统自带有keychain access这个管理工具，添加密钥文件可以把密钥文件一起添加到keychain access中，方法是ssh-add时多带一个-K参数   \n\n         ssh-add -K ~/.ssh/xxx_rsa\n  \n  2. 在~/.ssh中添加config文件，添加对应网站要使用的密钥文件  \n\n         Host gitlab.com  \n         RSAAuthentication yes \n         IdentityFile ~/.ssh/xxx_rsa\n\n","slug":"ssh/SSHNote","published":1,"date":"2016-06-30T18:06:47.000Z","updated":"2016-06-30T18:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq2mmqu500015ofyxgxfu768","content":"<h1 id=\"SSH网络协议使用杂记\"><a href=\"#SSH网络协议使用杂记\" class=\"headerlink\" title=\"SSH网络协议使用杂记\"></a><a href=\"https://zh.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">SSH网络协议</a>使用杂记</h1><p>最近寻觅各git托管服务，都选择了用ssh协议来拉取。以及最近因为各种原因接触得比较多，碰到的问题也多了，在这里面记录一下。  </p>\n<ul>\n<li>使用<pre><code>ssh-keygen -t rsa -C &quot;youremail-address&quot;\n</code></pre>创建ssh密钥时，<ol>\n<li>要求输入生成文件的目录，此时输入的目录需要是完整路径（也不能用～表示Home目录） </li>\n<li>要求输入passphrase,这个从目前的用法看就是即将生成的密钥文件的密码，把它添加到ssh agnet的时候需要输入这个密码</li>\n</ol>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>在ssh-add密钥后，碰到个问题是重启后还要再添加一遍。</p>\n<pre><code>ssh-add ~/.ssh/xxx_rsa  \n</code></pre><p>这个原因在于ssh-add添加密钥文件，只是用于添加指定文件到当前运行中的ssh agent的session中，重启后session重建，添加的密钥文件也就被重置了（似乎如果创建的密钥文件是默认名id_rsa，则不会有这个问题。可能重启后会添加默认的密钥文件吧）。<br>解决办法有两个：  </p>\n<ol>\n<li><p>在Mac OS X上，系统自带有keychain access这个管理工具，添加密钥文件可以把密钥文件一起添加到keychain access中，方法是ssh-add时多带一个-K参数   </p>\n<pre><code>ssh-add -K ~/.ssh/xxx_rsa\n</code></pre></li>\n<li><p>在~/.ssh中添加config文件，添加对应网站要使用的密钥文件  </p>\n<pre><code>Host gitlab.com  \nRSAAuthentication yes \nIdentityFile ~/.ssh/xxx_rsa\n</code></pre></li>\n</ol>\n</li>\n</ul>\n","excerpt":"<h1 id=\"SSH网络协议使用杂记\"><a href=\"#SSH网络协议使用杂记\" class=\"headerlink\" title=\"SSH网络协议使用杂记\"></a><a href=\"https://zh.wikipedia.org/wiki/Secure_Shell\">SSH网络协议</a>使用杂记</h1><p>最近寻觅各git托管服务，都选择了用ssh协议来拉取。以及最近因为各种原因接触得比较多，碰到的问题也多了，在这里面记录一下。  </p>\n<ul>\n<li>使用<pre><code>ssh-keygen -t rsa -C &quot;youremail-address&quot;\n</code></pre>创建ssh密钥时，<ol>\n<li>要求输入生成文件的目录，此时输入的目录需要是完整路径（也不能用～表示Home目录） </li>\n<li>要求输入passphrase,这个从目前的用法看就是即将生成的密钥文件的密码，把它添加到ssh agnet的时候需要输入这个密码</li>\n</ol>\n</li>\n</ul>","more":"<ul>\n<li><p>在ssh-add密钥后，碰到个问题是重启后还要再添加一遍。</p>\n<pre><code>ssh-add ~/.ssh/xxx_rsa  \n</code></pre><p>这个原因在于ssh-add添加密钥文件，只是用于添加指定文件到当前运行中的ssh agent的session中，重启后session重建，添加的密钥文件也就被重置了（似乎如果创建的密钥文件是默认名id_rsa，则不会有这个问题。可能重启后会添加默认的密钥文件吧）。<br>解决办法有两个：  </p>\n<ol>\n<li><p>在Mac OS X上，系统自带有keychain access这个管理工具，添加密钥文件可以把密钥文件一起添加到keychain access中，方法是ssh-add时多带一个-K参数   </p>\n<pre><code>ssh-add -K ~/.ssh/xxx_rsa\n</code></pre></li>\n<li><p>在~/.ssh中添加config文件，添加对应网站要使用的密钥文件  </p>\n<pre><code>Host gitlab.com  \nRSAAuthentication yes \nIdentityFile ~/.ssh/xxx_rsa\n</code></pre></li>\n</ol>\n</li>\n</ul>"},{"layout":"post","title":"Html Learning Note","_content":"\n# title元素(标签)\n    title元素 可定义文档的标题。\n    * 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。\n    * 同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。\n\n# HTML与css相互引用，搭建一个样式需要交叉","source":"_drafts/html_css_learning.md","raw":"---\nlayout : post\ntitle : Html Learning Note\n---\n\n# title元素(标签)\n    title元素 可定义文档的标题。\n    * 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。\n    * 同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。\n\n# HTML与css相互引用，搭建一个样式需要交叉","slug":"html_css_learning","published":0,"date":"2016-06-30T18:06:47.000Z","updated":"2016-06-30T18:06:47.000Z","comments":1,"photos":[],"link":"","_id":"ciq2mmquf000c5ofy5p9xq9gl","content":"<h1 id=\"title元素-标签\"><a href=\"#title元素-标签\" class=\"headerlink\" title=\"title元素(标签)\"></a>title元素(标签)</h1><pre><code>title元素 可定义文档的标题。\n* 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。\n* 同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。\n</code></pre><h1 id=\"HTML与css相互引用，搭建一个样式需要交叉\"><a href=\"#HTML与css相互引用，搭建一个样式需要交叉\" class=\"headerlink\" title=\"HTML与css相互引用，搭建一个样式需要交叉\"></a>HTML与css相互引用，搭建一个样式需要交叉</h1>","excerpt":"","more":"<h1 id=\"title元素-标签\"><a href=\"#title元素-标签\" class=\"headerlink\" title=\"title元素(标签)\"></a>title元素(标签)</h1><pre><code>title元素 可定义文档的标题。\n* 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。\n* 同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。\n</code></pre><h1 id=\"HTML与css相互引用，搭建一个样式需要交叉\"><a href=\"#HTML与css相互引用，搭建一个样式需要交叉\" class=\"headerlink\" title=\"HTML与css相互引用，搭建一个样式需要交叉\"></a>HTML与css相互引用，搭建一个样式需要交叉</h1>"},{"title":"修正git中错误的提交者姓名","_content":"# 情景  \n在一个仓库上提交时，用户名和邮箱给配置错了，看记录才知道。这可不能接受，看着可不舒服。幸好[github帮助页](https://help.github.com/articles/changing-author-info/)（此帮助页有[相对应的中文版本](http://dangzhiqiang.blog.51cto.com/7961271/1657864)）上有提供这种情况下的方法。   \n帮助页有下面的警告，对于公有仓库最好不去干这种改记录的事。不过我这是私有仓库就无所谓了。\n\n    Warning: This action is destructive to your repository's history. If you're collaborating on a repository with others, it's considered bad practice to rewrite published history. You should only do this in an emergency.\n\n<!--more-->\n# 开始重写历史\n1. 按帮助页上所写，需要先clone一个**裸版本库**([bare repository](https://segmentfault.com/q/1010000004683286))。查不到官方对裸版本库的说明或者定义，从搜索到的其它资料看，裸版本库就是一个只带历史信息文件的库，库的工作目录和文件并不会存在于目录中，只存在于历史中。远端共享的版本库经常就是裸版本库（可能是因为没检出工作目录省了空间？）。裸版本库还有其它方面未知的，后面找时间再探讨探讨。对于现在来说，我要修改历史信息的私人仓库来说完全是没这必要特意克隆一个裸版本库出来。不过为了试验修改完历史记录后，其它的fork或者clone是什么样合并这个历史记录的，还是跟着clone一个裸版本库出来好了。\n\n        git clone --bare https://github.com/user/repo.git\n\n2. 帮助页里面提供了一个shell脚本用来批量修改历史记录。如下：\n\n        #!/bin/sh\n\n        git filter-branch --env-filter '\n        OLD_EMAIL=\"your-old-email@example.com\"\n        CORRECT_NAME=\"Your Correct Name\"\n        CORRECT_EMAIL=\"your-correct-email@example.com\"\n        if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\n        then\n            export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n            export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\n        fi\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\n        then\n            export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n            export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\n        fi\n        ' --tag-name-filter cat -- --branches --tags\n\n    其中filter-branch这个命令在pro-git一书中可是把它标为核弹级选项，同时也在那书中看到了相类似的需要修改提交者姓名的需求和做法。至于两者的具体差异，后面可以找时间再研究下。\n\n3. 修改完后推送上去。到于后面的参数以及为何要加**'refs/heads/*'**这个，等后面有时间再看看吧。\n\n        git push --force --tags origin 'refs/heads/*'\n\n4. 强推时，如果远端分支受保护的话是强推不了的，会遇到下面的错误：\n\n        You are not allowed to force push code to a protected branch on this project.\n    \n    gitlab上默认是设置master分支是不允许强推的,需要到Project -> Protected Branches -> 把master分支点掉\n\n5. 让其它人拉取。帮助页在前面时有这么段话：  \n    \n        Note: Running this script rewrites history for all repository collaborators. After completing these steps, any person with forks or clones must fetch the rewritten history and rebase any local changes into the rewritten history.\n    \n    也就是其它已经Clone过这仓库的人拉取时要用rebase的方式（即将他们本地的修改历史逐个应用到这个新的历史树上）。否则的话，使用merge的方式将会将他们本地的历史记录（那个包含了错误名字的历史记录）重新合并到分支的历史中，并且又把那些错误名字的提交也合并了过来！！！  \n    所以其它人拉取时，要切记使用   \n        git pull --rebase <remote name> <branch name>\n    来拉取。","source":"_posts/git/GitChangeCommiterName.md","raw":"---\ntitle: 修正git中错误的提交者姓名\ntag: git\n---\n# 情景  \n在一个仓库上提交时，用户名和邮箱给配置错了，看记录才知道。这可不能接受，看着可不舒服。幸好[github帮助页](https://help.github.com/articles/changing-author-info/)（此帮助页有[相对应的中文版本](http://dangzhiqiang.blog.51cto.com/7961271/1657864)）上有提供这种情况下的方法。   \n帮助页有下面的警告，对于公有仓库最好不去干这种改记录的事。不过我这是私有仓库就无所谓了。\n\n    Warning: This action is destructive to your repository's history. If you're collaborating on a repository with others, it's considered bad practice to rewrite published history. You should only do this in an emergency.\n\n<!--more-->\n# 开始重写历史\n1. 按帮助页上所写，需要先clone一个**裸版本库**([bare repository](https://segmentfault.com/q/1010000004683286))。查不到官方对裸版本库的说明或者定义，从搜索到的其它资料看，裸版本库就是一个只带历史信息文件的库，库的工作目录和文件并不会存在于目录中，只存在于历史中。远端共享的版本库经常就是裸版本库（可能是因为没检出工作目录省了空间？）。裸版本库还有其它方面未知的，后面找时间再探讨探讨。对于现在来说，我要修改历史信息的私人仓库来说完全是没这必要特意克隆一个裸版本库出来。不过为了试验修改完历史记录后，其它的fork或者clone是什么样合并这个历史记录的，还是跟着clone一个裸版本库出来好了。\n\n        git clone --bare https://github.com/user/repo.git\n\n2. 帮助页里面提供了一个shell脚本用来批量修改历史记录。如下：\n\n        #!/bin/sh\n\n        git filter-branch --env-filter '\n        OLD_EMAIL=\"your-old-email@example.com\"\n        CORRECT_NAME=\"Your Correct Name\"\n        CORRECT_EMAIL=\"your-correct-email@example.com\"\n        if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\n        then\n            export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n            export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\n        fi\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\n        then\n            export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n            export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\n        fi\n        ' --tag-name-filter cat -- --branches --tags\n\n    其中filter-branch这个命令在pro-git一书中可是把它标为核弹级选项，同时也在那书中看到了相类似的需要修改提交者姓名的需求和做法。至于两者的具体差异，后面可以找时间再研究下。\n\n3. 修改完后推送上去。到于后面的参数以及为何要加**'refs/heads/*'**这个，等后面有时间再看看吧。\n\n        git push --force --tags origin 'refs/heads/*'\n\n4. 强推时，如果远端分支受保护的话是强推不了的，会遇到下面的错误：\n\n        You are not allowed to force push code to a protected branch on this project.\n    \n    gitlab上默认是设置master分支是不允许强推的,需要到Project -> Protected Branches -> 把master分支点掉\n\n5. 让其它人拉取。帮助页在前面时有这么段话：  \n    \n        Note: Running this script rewrites history for all repository collaborators. After completing these steps, any person with forks or clones must fetch the rewritten history and rebase any local changes into the rewritten history.\n    \n    也就是其它已经Clone过这仓库的人拉取时要用rebase的方式（即将他们本地的修改历史逐个应用到这个新的历史树上）。否则的话，使用merge的方式将会将他们本地的历史记录（那个包含了错误名字的历史记录）重新合并到分支的历史中，并且又把那些错误名字的提交也合并了过来！！！  \n    所以其它人拉取时，要切记使用   \n        git pull --rebase <remote name> <branch name>\n    来拉取。","slug":"git/GitChangeCommiterName","published":1,"date":"2016-06-30T18:06:47.000Z","updated":"2016-06-30T18:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq2mmqug000d5ofy29f7upo4","content":"<h1 id=\"情景\"><a href=\"#情景\" class=\"headerlink\" title=\"情景\"></a>情景</h1><p>在一个仓库上提交时，用户名和邮箱给配置错了，看记录才知道。这可不能接受，看着可不舒服。幸好<a href=\"https://help.github.com/articles/changing-author-info/\" target=\"_blank\" rel=\"external\">github帮助页</a>（此帮助页有<a href=\"http://dangzhiqiang.blog.51cto.com/7961271/1657864\" target=\"_blank\" rel=\"external\">相对应的中文版本</a>）上有提供这种情况下的方法。<br>帮助页有下面的警告，对于公有仓库最好不去干这种改记录的事。不过我这是私有仓库就无所谓了。</p>\n<pre><code>Warning: This action is destructive to your repository&apos;s history. If you&apos;re collaborating on a repository with others, it&apos;s considered bad practice to rewrite published history. You should only do this in an emergency.\n</code></pre><a id=\"more\"></a>\n<h1 id=\"开始重写历史\"><a href=\"#开始重写历史\" class=\"headerlink\" title=\"开始重写历史\"></a>开始重写历史</h1><ol>\n<li><p>按帮助页上所写，需要先clone一个<strong>裸版本库</strong>(<a href=\"https://segmentfault.com/q/1010000004683286\" target=\"_blank\" rel=\"external\">bare repository</a>)。查不到官方对裸版本库的说明或者定义，从搜索到的其它资料看，裸版本库就是一个只带历史信息文件的库，库的工作目录和文件并不会存在于目录中，只存在于历史中。远端共享的版本库经常就是裸版本库（可能是因为没检出工作目录省了空间？）。裸版本库还有其它方面未知的，后面找时间再探讨探讨。对于现在来说，我要修改历史信息的私人仓库来说完全是没这必要特意克隆一个裸版本库出来。不过为了试验修改完历史记录后，其它的fork或者clone是什么样合并这个历史记录的，还是跟着clone一个裸版本库出来好了。</p>\n<pre><code>git clone --bare https://github.com/user/repo.git\n</code></pre></li>\n<li><p>帮助页里面提供了一个shell脚本用来批量修改历史记录。如下：</p>\n<pre><code>#!/bin/sh\n\ngit filter-branch --env-filter &apos;\nOLD_EMAIL=&quot;your-old-email@example.com&quot;\nCORRECT_NAME=&quot;Your Correct Name&quot;\nCORRECT_EMAIL=&quot;your-correct-email@example.com&quot;\nif [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]\nthen\n    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;\n    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;\nfi\nif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]\nthen\n    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;\n    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;\nfi\n&apos; --tag-name-filter cat -- --branches --tags\n</code></pre><p> 其中filter-branch这个命令在pro-git一书中可是把它标为核弹级选项，同时也在那书中看到了相类似的需要修改提交者姓名的需求和做法。至于两者的具体差异，后面可以找时间再研究下。</p>\n</li>\n<li><p>修改完后推送上去。到于后面的参数以及为何要加<strong>‘refs/heads/*’</strong>这个，等后面有时间再看看吧。</p>\n<pre><code>git push --force --tags origin &apos;refs/heads/*&apos;\n</code></pre></li>\n<li><p>强推时，如果远端分支受保护的话是强推不了的，会遇到下面的错误：</p>\n<pre><code>You are not allowed to force push code to a protected branch on this project.\n</code></pre><p> gitlab上默认是设置master分支是不允许强推的,需要到Project -&gt; Protected Branches -&gt; 把master分支点掉</p>\n</li>\n<li><p>让其它人拉取。帮助页在前面时有这么段话：  </p>\n<pre><code>Note: Running this script rewrites history for all repository collaborators. After completing these steps, any person with forks or clones must fetch the rewritten history and rebase any local changes into the rewritten history.\n</code></pre><p> 也就是其它已经Clone过这仓库的人拉取时要用rebase的方式（即将他们本地的修改历史逐个应用到这个新的历史树上）。否则的话，使用merge的方式将会将他们本地的历史记录（那个包含了错误名字的历史记录）重新合并到分支的历史中，并且又把那些错误名字的提交也合并了过来！！！<br> 所以其它人拉取时，要切记使用   </p>\n<pre><code>git pull --rebase &lt;remote name&gt; &lt;branch name&gt;\n</code></pre><p> 来拉取。</p>\n</li>\n</ol>\n","excerpt":"<h1 id=\"情景\"><a href=\"#情景\" class=\"headerlink\" title=\"情景\"></a>情景</h1><p>在一个仓库上提交时，用户名和邮箱给配置错了，看记录才知道。这可不能接受，看着可不舒服。幸好<a href=\"https://help.github.com/articles/changing-author-info/\">github帮助页</a>（此帮助页有<a href=\"http://dangzhiqiang.blog.51cto.com/7961271/1657864\">相对应的中文版本</a>）上有提供这种情况下的方法。<br>帮助页有下面的警告，对于公有仓库最好不去干这种改记录的事。不过我这是私有仓库就无所谓了。</p>\n<pre><code>Warning: This action is destructive to your repository&apos;s history. If you&apos;re collaborating on a repository with others, it&apos;s considered bad practice to rewrite published history. You should only do this in an emergency.\n</code></pre>","more":"<h1 id=\"开始重写历史\"><a href=\"#开始重写历史\" class=\"headerlink\" title=\"开始重写历史\"></a>开始重写历史</h1><ol>\n<li><p>按帮助页上所写，需要先clone一个<strong>裸版本库</strong>(<a href=\"https://segmentfault.com/q/1010000004683286\">bare repository</a>)。查不到官方对裸版本库的说明或者定义，从搜索到的其它资料看，裸版本库就是一个只带历史信息文件的库，库的工作目录和文件并不会存在于目录中，只存在于历史中。远端共享的版本库经常就是裸版本库（可能是因为没检出工作目录省了空间？）。裸版本库还有其它方面未知的，后面找时间再探讨探讨。对于现在来说，我要修改历史信息的私人仓库来说完全是没这必要特意克隆一个裸版本库出来。不过为了试验修改完历史记录后，其它的fork或者clone是什么样合并这个历史记录的，还是跟着clone一个裸版本库出来好了。</p>\n<pre><code>git clone --bare https://github.com/user/repo.git\n</code></pre></li>\n<li><p>帮助页里面提供了一个shell脚本用来批量修改历史记录。如下：</p>\n<pre><code>#!/bin/sh\n\ngit filter-branch --env-filter &apos;\nOLD_EMAIL=&quot;your-old-email@example.com&quot;\nCORRECT_NAME=&quot;Your Correct Name&quot;\nCORRECT_EMAIL=&quot;your-correct-email@example.com&quot;\nif [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]\nthen\n    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;\n    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;\nfi\nif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]\nthen\n    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;\n    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;\nfi\n&apos; --tag-name-filter cat -- --branches --tags\n</code></pre><p> 其中filter-branch这个命令在pro-git一书中可是把它标为核弹级选项，同时也在那书中看到了相类似的需要修改提交者姓名的需求和做法。至于两者的具体差异，后面可以找时间再研究下。</p>\n</li>\n<li><p>修改完后推送上去。到于后面的参数以及为何要加<strong>‘refs/heads/*’</strong>这个，等后面有时间再看看吧。</p>\n<pre><code>git push --force --tags origin &apos;refs/heads/*&apos;\n</code></pre></li>\n<li><p>强推时，如果远端分支受保护的话是强推不了的，会遇到下面的错误：</p>\n<pre><code>You are not allowed to force push code to a protected branch on this project.\n</code></pre><p> gitlab上默认是设置master分支是不允许强推的,需要到Project -&gt; Protected Branches -&gt; 把master分支点掉</p>\n</li>\n<li><p>让其它人拉取。帮助页在前面时有这么段话：  </p>\n<pre><code>Note: Running this script rewrites history for all repository collaborators. After completing these steps, any person with forks or clones must fetch the rewritten history and rebase any local changes into the rewritten history.\n</code></pre><p> 也就是其它已经Clone过这仓库的人拉取时要用rebase的方式（即将他们本地的修改历史逐个应用到这个新的历史树上）。否则的话，使用merge的方式将会将他们本地的历史记录（那个包含了错误名字的历史记录）重新合并到分支的历史中，并且又把那些错误名字的提交也合并了过来！！！<br> 所以其它人拉取时，要切记使用   </p>\n<pre><code>git pull --rebase &lt;remote name&gt; &lt;branch name&gt;\n</code></pre><p> 来拉取。</p>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciq2mmqtz00005ofypcqg30go","tag_id":"ciq2mmqu700025ofy14ec0mt0","_id":"ciq2mmquc00075ofy390rv9dj"},{"post_id":"ciq2mmqtz00005ofypcqg30go","tag_id":"ciq2mmqub00035ofy7tlxnmgi","_id":"ciq2mmqud00085ofy1rp3dy3k"},{"post_id":"ciq2mmqtz00005ofypcqg30go","tag_id":"ciq2mmqub00045ofyf6tgeu4e","_id":"ciq2mmqud00095ofy7hgqu4fo"},{"post_id":"ciq2mmqtz00005ofypcqg30go","tag_id":"ciq2mmquc00055ofyq1b8s963","_id":"ciq2mmqud000a5ofylaj89wsh"},{"post_id":"ciq2mmqu500015ofyxgxfu768","tag_id":"ciq2mmquc00065ofy2aq50xqc","_id":"ciq2mmqud000b5ofysza23df4"},{"post_id":"ciq2mmqug000d5ofy29f7upo4","tag_id":"ciq2mmqui000e5ofy0xtyol6p","_id":"ciq2mmqui000f5ofyqxih0u6f"}],"Tag":[{"name":"Shadowsocks","_id":"ciq2mmqu700025ofy14ec0mt0"},{"name":"plist","_id":"ciq2mmqub00035ofy7tlxnmgi"},{"name":"Alfred","_id":"ciq2mmqub00045ofyf6tgeu4e"},{"name":"python","_id":"ciq2mmquc00055ofyq1b8s963"},{"name":"ssh","_id":"ciq2mmquc00065ofy2aq50xqc"},{"name":"git","_id":"ciq2mmqui000e5ofy0xtyol6p"}]}}